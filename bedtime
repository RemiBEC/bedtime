#!/usr/bin/perl
#
# mydaemon.pl by Andrew Ault, www.andrewault.net
#
# Free software. Use this as you wish.
#
# Throughout this template "mydaemon" is used where the name of your daemon should
# be, replace occurrences of "mydaemon" with the name of your daemon.
#
# This name will also be the exact name to give this file (WITHOUT a ".pl" extension).
#
# It is also the exact name to give the start-stop script that will go into the
# /etc/init.d/ directory.
#
# It is also the name of the log file in the /var/log/ directory WITH a ".log"
# file extension.
#
# Replace "# do something" with your super useful code.
#
# Use "# logEntry("log something");" to log whatever your need to see in the log.
#
use strict;
use DBI;
use Getopt::Std;
use POSIX;
use BedtimeDB;
use File::Basename;

# Path to the perl scripts
my $path = dirname($0);

# Connect to the database
my $dbh = &BedtimeDB::dbconn;

# Option d for dhcp, u for update, m for manufacturers, t for tail leases, otherwise go daemon
getopts('dumt');
our($opt_d,$opt_u,$opt_m,$opt_t);

my ($logging, $pidFile); 

if ($opt_d) {
   exec ("$path/dhcp_slurp.pl");
} elsif ($opt_u) {
   exec ("$path/update_ipt.pl");
} elsif ($opt_m) {
   exec ("$path/get_manlst.pl");
} else {
   # Get the logging variable from the database
   my $logging = &BedtimeDB::get_val('logging');

   # And the log path
   my $logFilePath = &BedtimeDB::get_val('logpath');

   # And the pid path
   my $pidFilePath = &BedtimeDB::get_val('pidpath');

   my $daemonName    = $0;
   my $sleepMainLoop = 120;
   my $logFile       = $logFilePath . $daemonName . ".log";
   my $pidFile       = $pidFilePath . $daemonName . ".pid";

   # Do the daemon stuff
   use POSIX qw(setsid);
   chdir '/';
   umask 0;
   open STDIN,  '/dev/null'   or die "Can't read /dev/null: $!";
   open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!";
   open STDERR, '>>/dev/null' or die "Can't write to /dev/null: $!";
   defined( my $pid = fork ) or die "Can't fork: $!";
   exit if $pid;

   # dissociate this process from the controlling terminal that started it and stop being part
   # of whatever process group this process was a part of.
   POSIX::setsid() or die "Can't start a new session.";

   # callback signal handler for signals.
   $SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signalHandler;
   $SIG{PIPE} = 'ignore';

   # create pid file in /var/run/
   open PID, ">$pidFile" or die "Can't open PID file, /dev/null: $!";
   print PID $$ or die "Can't write PID file, /dev/null: $!";
   close PID;

   # turn on logging
   if ($logging) {
      open LOG, ">>$logFile";
      select((select(LOG), $|=1)[0]); # make the log file "hot" - turn off buffering
   } 

   # "infinite" loop where some useful process happens
   if ($opt_t) {
      open my $pipe, "-|", "/usr/bin/tail", "-f", "/var/log/messages" or die "could not start tail on SampleLog.log: $!";
      while (<$pipe>) {
         system("$path/dhcp_slurp") if (m/dhcpd: Wrote \d+ leases to leases file/);
      }
   } else {
      while (1) {
         sleep($sleepMainLoop);
         
         # logEntry("log something"); # use this to log whatever you need to
      }
   }
}

# add a line to the log file
sub logEntry {
   my ($logText) = @_;
   my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime(time);
   my $dateTime = sprintf "%4d-%02d-%02d %02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
   if ($logging) {
      print LOG "$dateTime $logText\n";
   }
}

# catch signals and end the program if one is caught.
sub signalHandler {
   unlink $pidFile;
   $dbh->disconnect;
   close LOG if ($logging);
   exit();
}

# do this stuff when exit() is called.
END {
   close LOG if ($logging);
   $dbh->disconnect;
   unlink $pidFile;
}
