#!/usr/bin/perl
#
# mydaemon.pl by Andrew Ault, www.andrewault.net
#
# Free software. Use this as you wish.
#
# Throughout this template "mydaemon" is used where the name of your daemon should
# be, replace occurrences of "mydaemon" with the name of your daemon.
#
# This name will also be the exact name to give this file (WITHOUT a ".pl" extension).
#
# It is also the exact name to give the start-stop script that will go into the
# /etc/init.d/ directory.
#
# It is also the name of the log file in the /var/log/ directory WITH a ".log"
# file extension.
#
# Replace "# do something" with your super useful code.
#
# Use "# logEntry("log something");" to log whatever your need to see in the log.
#
use strict;
use DBI;
use Getopt::Std;
use POSIX;

# Read the conf file into an array and filter out all lines consisting of just white space and comments
open (CONF,'/etc/bedtime.conf') or die "Cannot open configuration file - $!\n";
my @conf = <CONF>; close CONF;
@conf = grep (!/^\s*$/,@conf);
@conf = grep (!/^#/,@conf);

# Read the remaining lines into a hash split on =
my %vals;
foreach (@conf) {
   chomp;
   my @pair = split(/\s*=\s*/);
   $vals{$pair[0]}=$pair[1];
}

# Collect the credentials and connect to the database
my $user = $vals{'dbuser'};
my $pass = $vals{'dbupass'};
my $dbis = "DBI:mysql:".$vals{'dbname'}.":".$vals{'dbhost'};
my $dbh = DBI->connect($dbis,$user,$pass) or die "Cannot connect to database $dbis with user $user - $!\n";

# Option u for update, d for dhcp, otherwise go daemon
getopts('du');
our($opt_d,$opt_u);

my $dieNow  = 0;
my $logging = 1;
my $pidFile;

if ($opt_d) {
   slurpDHCP();
   exit;
} elsif ($opt_u) {
   updateIPtables();
   exit;
} else {
   # Get the logging variable from the database
   my $sth = $dbh->prepare("select value from settings where variable='logging';") or die "Cannot prepare query: $dbh->errstr";
   my $res = $sth->execute or die "Cannot execute query: $sth->errstr";
   my $logvar = $sth->fetchrow_array();
   $res = $sth->finish;
   $logging = 0 if ($logvar == 'no'); 

   # And the log path
   $sth = $dbh->prepare("select value from settings where variable='logpath';") or die "Cannot prepare query: $dbh->errstr";
   my $res = $sth->execute or die "Cannot execute query: $sth->errstr";
   my $logFilePath = $sth->fetchrow_array();
   $res = $sth->finish;

   # And the pid path
   $sth = $dbh->prepare("select value from settings where variable='pidpath';") or die "Cannot prepare query: $dbh->errstr";
   my $res = $sth->execute or die "Cannot execute query: $sth->errstr";
   my $pidFilePath = $sth->fetchrow_array();
   $res = $sth->finish;

   my $daemonName    = $0;
   my $sleepMainLoop = 2;                                     # number of seconds to wait between "do something" execution after queue is clear
   my $logFile       = $logFilePath . $daemonName . ".log";
   my $pidFile       = $pidFilePath . $daemonName . ".pid";

   # daemonizs
   use POSIX qw(setsid);
   chdir '/';
   umask 0;
   open STDIN,  '/dev/null'   or die "Can't read /dev/null: $!";
   open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!";
   open STDERR, '>>/dev/null' or die "Can't write to /dev/null: $!";
   defined( my $pid = fork ) or die "Can't fork: $!";
   exit if $pid;

   # dissociate this process from the controlling terminal that started it and stop being part
   # of whatever process group this process was a part of.
   POSIX::setsid() or die "Can't start a new session.";

   # callback signal handler for signals.
   $SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signalHandler;
   $SIG{PIPE} = 'ignore';

   # create pid file in /var/run/
   open PID, ">$pidFile" or die "Can't open PID file, /dev/null: $!";
   print PID $$ or die "Can't write PID file, /dev/null: $!";
   close PID;

   # turn on logging
   if ($logging) {
      open LOG, ">>$logFile";
      select((select(LOG), $|=1)[0]); # make the log file "hot" - turn off buffering
   } 

   # "infinite" loop where some useful process happens
   until ($dieNow) {
      sleep($sleepMainLoop);
      # logEntry("log something"); # use this to log whatever you need to
   }
}

# add a line to the log file
sub logEntry {
   my ($logText) = @_;
   my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime(time);
   my $dateTime = sprintf "%4d-%02d-%02d %02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
   if ($logging) {
      print LOG "$dateTime $logText\n";
   }
}

# catch signals and end the program if one is caught.
sub signalHandler {
   $dieNow = 1;    # this will cause the "infinite loop" to exit
}

# do this stuff when exit() is called.
END {
   close LOG if ($logging);
   $dbh->disconnect;
   unlink $pidFile;
}

sub slurpDHCP {
   # Get leases file from the settings table
   my $sth = $dbh->prepare("select value from settings where variable='dhcp_leases';") or die "Cannot prepare query: $dbh->errstr";
   my $res = $sth->execute or die "Cannot execute query: $sth->errstr";
   my $lease_f = $sth->fetchrow_array();
   $res = $sth->finish;

   # Slurp the leases file into a hash
   open (LEASE,$lease_f);
   my @lease = <LEASE>; close(LEASE);

   # The only things we care about are the MAC and the IP
   my @devs = grep { $_ =~ /^\s*lease|^\s*hardware/} @lease;
   my $devs = join("", @devs);
   # Replace the newline between the IP and the MAC with a ### marker
   $devs =~ s/\s*{\s*\n\s*/###/g;
   # Get rid of the text to leave just IP###MAC
   $devs =~ s/\s*lease\s*|\s*hardware ethernet\s*//g;
   # Remove the trailing ; from the MAC
   $devs =~ s/;/\n/g;
   chomp($devs);
   # Create an array from the devices string and parse each line
   @devs = split(/\n/,$devs);
   foreach (@devs) {
      my @row = split(/###/);
      my $ip = $row[0]; my $mac = $row[1];
      # Remove the : separators and set to uppercase
      $mac =~ s/://g; $mac = uc($mac);
      # Find if the device is already in the database
      $sth = $dbh->prepare("select count(*) from device where lpad(hex(mac),12,'0')=lpad('$mac',12,'0');") or die "Cannot prepare query: $dbh->errstr";
      $res = $sth->execute or die "Cannot execute query: $sth->errstr";
      my $sql;
      if ($sth->fetchrow_array() > 0) {
         # If it is already in the database, just update the IP. Leave owner and first seen data intact
         $sql = "update device set ip=inet_aton('$ip') where lpad(hex(mac),12,'0')=lpad('$mac',12,'0');";
      } else {
         # A new device gets first seen
         $sql = "insert into device set mac=x'$mac', ip=inet_aton('$ip'), first_seen=now();";
      }
      $res = $sth->finish;
      $sth = $dbh->prepare($sql) or die "Cannot prepare query: $dbh->errstr";
      $res = $sth->execute or die "Cannot execute query: $sth->errstr";
    }
}
